---
title: Lecture 10
week: 8
lecture_date: 2022-11-14
author: Carey Nachenberg
layout: lecture
parent: Lecture Notes
---

## Table of Contents
{: .no_toc }

{:toc}
- dummy item

## What is OOP?
OOP is a programming paradigm based on the concept of objects. As we'll see, many OOP languages also have classes, but classes are not required for a language to be OOP. In the original conception of OOP, objects work with each other by sending messages to each other, in the form of method calls.

## Brief History of OOP

We covered a brief history of OOP languages in class, including:

- Sketchpad: Developed by Ivan Sutherland, it was an oscilloscope-based CAD program from 1963. It pioneered concepts like classes, objects, inheritance, and late binding/polymorphism. It wasn't a language but a CAD program, but it embodied many OOP concepts.
- The record: The notion of a record or struct was developed by Tony Hoare in 1966. He noticed that many things in the real world can be modeled as objects with a set of related fields, and that objects of the same category or type (e.g., Dogs) often had similar sets of fields, defining classes of objects.
- Simula: Between 1962-1966, Ole-Johan Dahl and Kristen Nygaard, two scientists in Norway developed the Simula language to make it easier to build military simulations.  One big leap with Simula was that it defined objects as having both data fields (like Hoare) and functions/methods to operate on that data. Simula pioneered the following items:
-- Classes have both functions and data
-- Objects can be instantiated from Classes
-- Use of the dot notation for object member access (e.g., doggo.bark())
-- Inheritance
-- Virtual functions/procedures to facilitate polymorphism/dynamic binding
-- Dynamic binding (we'll talk about this later)

Take a look at some Simula classes to see how close they look to modern C++, Java, etc.:

```
CLASS POINT(X,Y); REAL X, Y; 
  COMMENT***CARTESIAN REPRESENTATION
BEGIN
  BOOLEAN PROCEDURE EQUALS(P); REF(POINT) P;
    IF P =/= NONE THEN 
      EQUALS := ABS(X-P.X) + ABS(Y-P.Y) < 0.00001; 
  REAL PROCEDURE DISTANCE(P); REF(POINT) P;
    IF P == NONE THEN ERROR ELSE
      DISTANCE := SQRT( (X-P.X)**2 + (Y-P.Y)**2 );
END***POINT***
```

```
POINT CLASS COLOREDPOINT(C); COLOR C;
BEGIN
  BOOLEAN PROCEDURE EQUALS(Q); REF(COLOREDPOINT) Q;
    ...;
END***COLOREDPOINT**
```

```
REF(POINT) P; REF(COLOREDPOINT) CP;
P :- NEW POINT(1.0,2.5);
CP :- NEW COLOREDPOINT(2.5,1.0,RED);
CP.C := BLUE;
```

- Smalltalk: Meanwhile, Alan Kay (who is a UCLA emeritus prof!) was at Xerox PARC developing the DynaBook - a precursor to the modern laptop. Alan wanted to design a language that could be used to implement an OS, apps, everything. Inspired by his own background in math and biology, SketchPad, Hoare's records, and Simula, he came up with a broad conception of OOP, and developed SmallTalk. While most languages have adopted Simula-like syntax, Kay's ideas about OOP have continued to shape the field, and Kay is credited with coining the term OOP. In Smalltalk:

- Everything is an object
- Objects send messages to other objects to request behaviors (like cells in an organism, or nodes on the arpanet)
- Each object decides how/if to respond/behave when it receives a message
- Objects may pass messages to other objects to get their work done
- Methods may return objects as their result to a sender

Here's an example smalltalk program below.

```smalltalk
"Snippet of Smalltalk code that sings '99 bottles of beer'"
99 to: 1 
   by: -1 
   do: [:j | Transcript show: (j printString),' bottles of beer on the wall ';cr].

Transcript show: 'No more bottles of beer on the wall!;cr.
``` 

This code implements a loop by sending the object 99 (EVERYTHING is an object in Smalltalk) a message with three parameters: (1) to, (2) by, and (3) do. The first parameter tells the 99 object what it should iterate to. The second parameter tells 99 how much to increment during each iteration, and the final parameter is a block of code to run during each iteration.

Think of this code as being:
```cpp
Number n(99);
n.to_by_do(1,-1,lambda to print stuff)
```

To briefly conclude our history, in the 70s and 80s, Bjarne Stroustrup created C With Classes, later known as C++, by marrying ideas from Simula with C.  And then Java, C#, Scala, Kotlin and Swift followed in the 2000s and 2010s.

## Essential Components of OOP

So what are the essential components of OOP?

- *Classes*: A class is a blueprint for creating new objects – it defines a public interface, code for methods, and data fields. 
- *Interfaces*: An interface is a related group of function prototypes that we want one or more classes to implement.
- *Objects*: An object represents a particular "thing" - like a circle of radius 5 at location (1,3). Each object  has its own interface, code, and field values.
- *Inheritance*: A derived class inherits either the code, the interface, or both from a base class.
The derived class can override the base class's code or add to its interface.
- *Subtype Polymorphism*: Code designed to operate on an object of type T (e.g., Person) can operate on any object that is a subtype of T (e.g., Student).  
- *Dynamic Dispatch*: The actual code that runs when a method is called depends on the target object, and can only be determined at runtime.
- *Encapsulation*: Encapsulation is the bundling of a public interface and private data fields/code together into a cohesive unit. 

## Encapsulation Deep Dive

Encapsulation is the guiding principle behind the OOP paradigm. There are two facets to encapsulati0n:
- We bundle related *public interface*, *data*, and *code* together into a cohesive, problem-solving machine.
- We *hide data/implementation* details of that machine from its clients – forcing them to use its public interface.

Encapsulation has many benefits:
- Simpler programs: We have reduced coupling between modules, simplifying our programs
- Easier Improvements: We can improve implementations without impacting other components
- Better Modularity: We can build a class once and use it over and over in different contexts

A big part of software engineering is anticipating future changes. One reason for OOP's success is that it helps people build software that is resilient to many types of change.

## Deep Dive: Classes, Interfaces, Objects

- Class: A class is a blueprint that specifies a public interface, code, and fields that make up a type of object.
- Interface: An interface is a related group of function prototypes that describes behaviors that we want one or more classes to implement.
- Object: An object is a distinct value/entity, often created from a class blueprint – each object has its own logical copy of data and methods.

### Classes

Here'a C++ class which shows most of the major component of a typical class:

```cpp
// Class Declaration
class Nerd { 
 public:
  Nerd(const string& name);
  ~Nerd();
  string talk() const;

 private:
  string name_;
  int IQ_;

  void study(int hrs);
};

// Implementation
Nerd::Nerd(const string& name) {
  name_ = name;
  IQ_ = 100;
  study(3);
}

Nerd::~Nerd() { IQ_ = 0; }
string Nerd::talk() const  { return name_ + " likes closures."; }
void Nerd::study(int hrs) { IQ_ += hrs; }
```

Key elements of classes include: the class name, constructors, destructors, public and private member variables/functions, the public interface, and method implementations.

#### Every time you define a class you define a new type

When you define a new class, like Nerd above, it also defines a new type. If the class is a concrete class (i.e., all of its methods have { definitions }) and not an *abstract class* then you can use this new type to define all of the following: objects, object references/pointers, and references. A class is a class, and a type is a type, and they're different entities. 

### Interfaces

An interface is a related group of function prototypes (declarations without { bodies }) that describes behaviors that we want one or more classes to implement. An interface specifies what we want one or more classes to do, but not how to implement these interfaces.

```java
// Java interface definition for shapes
interface Shape {
  public double area();
  public double perimeter();
  public void scale(double factor);
}
```

And here's an example from C++:

```cpp
// C++ interface definition for shapes
class Shape {
 public:
   virtual double area() = 0;
   virtual double perimeter() = 0;
   virtual void scale(double factor) = 0;
};
```

As you can see above, C++ we use pure-virtual functions within a class to define an interface.

Once we define an interface, we can ask a class to *implement* or *inherit* from it. Here's an example from Java that implements the Shape interface we defined above. You can see that the Square class provides { definitions/implementations } for each function declared in the interface. We can now say that a Square *supports*, *implements*, or *inherits* the Shape interface (that's the terminology you'd use).

```java
class Square implements Shape {
 ...
 public double area()
   { return w_ * w_; }
 public double perimeter()
   { return 4 * w_; }
 ...
}
```

Interfaces enable otherwise-unrelated classes to provide a common set of behaviors without actually inheriting any code like we learned about in CS32.

#### Every time you define an interface you define a new reference type

When you define a new interface, like Shape above, it also defines a new type - specifically a *reference* type. Since an interface lacks any function { definitions/code }, you can't use a reference type to define full objects:

```java
Shape x = new Shape();  // The "new Shape()" part doesn't work
```

But you can use reference types to define all of the following: object references, pointers and references, depending on which of the above your language supports. So we can use reference types like this:

```java
  void someFunc(Shape s) { ... }  // s is an object reference in Java, so this works
```

So here's a question: If each interface defines a type, and each class defines a type, and a class implements an interface – does the class have two types? The answer is Yes! For example our Square class actually has TWO types - it is of the Square type AND it is of the Shape type!  And you can pass a Square to any function that accepts either a Square or a Shape object reference, pointer or reference!

define all of the following: objects, object references/pointers, and references. A class is a class, and a type is a type, and they're different entities. 

### Objects

An object is a distinct value, often created from a class blueprint – each object has its own copy of fields and methods.

In most languages, objects are *instantiated* by using a class, e.g.:

```cpp
class Circle { ... };

Circle x;  // instantiates a Circle object named x in C++
```

A class serves as a blueprint for creating new objects.  But this is not always the case! In some languages, like JavaScript, there are no classes, only objects! Here's some code to creat a javascript object containing information about famous computer scientist Alan Kay.  It has a bunch of fields (key-value pairs) as well as a method, fullName().  You can also see that we can update our object to add a function - we add tellJoke() to our object. Finally, we use our object to ask Alan to tell a joke.  No classes are involved in creating this object.

```js
// Javascript had objects but not classes!
var student1 = {
  first: "Alan",
  last: "Kay",
  phone: "818-555-1212",
  student_id: 958333245,
  fullName: function() 
    { return this.first + " " + this.last; }
};

student1["tellJoke"] = function() { return "Two mice walk into a bar"; }

console.log(student1.fullName() + " says " + student1.tellJoke());
```
### Classes, Interfaces, Object Challenges

Q: Why even support the notion of a class in a language? What are the pros and cons of using a model like JavaScript with just objects?

A: Classes enable us to create a consistent set of objects, all generated in a consistent way based on the class specification. Classes enable us to define a new type, which we'll see is useful for polymorphism in statically typed languages

Q: JavaScript can dynamically add methods to objects, is there any reason we can't dynamically add/remove methods to/from classes?

While most/all static languages don't allow this, dynamically typed languages absolutely allow this, Python being one example. In a statically typed language, adding a new method would potentially change the class interface which would complicate compilation/interpretation, but technically this could be done too.

## Shallow-dive Into Classes

Let's talk about some key aspects of classes that you may not have known before.

### Class Fields and Class Methods

Normally, each object has its own copy of every member variable (e.g., each Stack object has its own array/count). But sometimes we want to allow the overall class to have its own fields. A "class field" is one that's associated with the overall class – it's stored once in memory and is usable by all of the class's objects. A "class method" is similarly associated with the overall class, and may only operates on class field.

What are the uses for class fields/methods?

*Defining Class-level Constants*: If we have a constant that's shared by all objects of a class, we make it a class field.

*Counting the Number of Objects*: If we want to keep a count of how many objects have been instantiated, the class can track this with a class field.

*Assigning Each Object a Unique ID*: If we want to assign each object a unique ID number, we can use a class field to hold the next ID to be assigned.

#### Class Fields

Here's an example from C++. We'll update our Nerd class to not only track names/IQs for individual nerds, but to track how many total nerd objects there are overall. We'll do this tracking with a class field that keep the total count (num_nerds_) and use our constructor/destructor to up/down the count. 

```cpp
// nerd.h
class Nerd { 
 public:
  Nerd(const string& name) {
   name_ = name;
   IQ_ = 100;
   ++num_nerds_;
  }
  ~Nerd() {
   --num_nerds_;
  }
  string talk() const { ... }

 private:
  string name_;
  int IQ_;
  static int num_nerds_;

  void study(int hrs) { ... }
};
```

```cpp
// nerd.cpp
// initialize class fields in the cpp; initializes value of our class field.
int Nerd::num_nerds_ = 0;
```

In C++, when we define a member variable as *static* that means that it's a class-level field, stored in memory just once for the class. Each object/instance doesn't store this field within their memory! Instead, the field is stored once in the static data area of the process's RAM per class and all object methods just refer to this singleton value. So all objects share the same singleton variabl num_nerds_.

#### Class Methods

A class method is one that can ONLY access class fields - it cannot access ANY instance fields (e.g., name_ or IQ_) inside of an object, because it's not associated with any particular object. It's associated instead with the overall class.  Here's an example in C++:

```cpp
class Foo { 
 public:
  Foo(int v) {
    val_ = v;
    ++num_foos_;
  }
  ~Foo() { --num_foos_; }
  int inc()
   { ++val_; return val_; }

  static int getActiveFooCount()
   { return num_foos_; }

 private:
  int val_;
  static int num_foos_;
};

int main() {
  Foo a(5);

  cout << "Count of foos: " << a.getActiveFooCount() << endl;
  cout << "Count of foos: " << Foo::getActiveFooCount();
}

```

In the above example, the getActiveFooCount() method is a class-level method, because it's define as static.  It may only access class-level fields or call other class-level methods, since it knows nothing about instance-level fields/methods. As you can see, in C++ we have two ways of calling a class-level method: using an instance variable name, like *a* followed by a dot, or by using the class name, like *Foo*, followed by two colons. Other languages vary in the syntax used to call class-level methods.

Here's an example from python - you can see we use the class name (e.g., Foo) followed by a period to call a class method or access a class variable:

```python
# Python class variables/functions
class Foo:
 num_foos_ = 0  # class variable

 def __init__(self, v):
   val_ = v
   Foo.num_foos_ = Foo.num_foos_ + 1

 def __del__(self):
   Foo.num_foos_ = Foo.num_foos_ - 1

 def inc(self):
   val_ = val_ + 1
   return val_

 @classmethod
 def get_num_foos(cls):
   return cls.num_foos_

a = Foo(5)
b = Foo(6)
print("Number of foos:", Foo.get_num_foos())

```

And here's an example from Java. It looks pretty similar to C++ in that it uses static to define class methods/fields:

```java
// Java class variable/method example
public class Nerd {
  private String name;
  private int IQ;
  private static int num_nerds;
  
  static {
    num_nerds = 0;
  }
  public Nerd(String name) {
    this.name = name;
    this.IQ = 100;
    num_nerds++;
  }
  public void finalize() {
    this.IQ = 0;
    num_nerds--;
  }

  public static int getNumNerds() {
    return num_nerds;
  }
}
```

```java
// Java calling a class method getNumNerds()
public static void main(String args[]) {
  Nerd n = new Nerd("Carey");
  System.out.println("There are " + Nerd.getNumNerds() + " nerds.");
}

```

### Class Field and Class Method Challenge

Q: When would we want to use class-level methods?
A: We use class-level methods when a method only accesses class-level variables and thus doesn't need access to member variables. We might also use class-level methods when defining a class that contains a bunch of related functions that aren't associatee with individual objects. For example, imagine we're defining a Math class with functions like sqrt(), exp(), tan(), cos(), etc. Those functions could all be class functions and placed into a Math class.

```cpp
class MathLibrary {
   static double sqrt(double x); // doesn't need access to member variables
   static double exp(double x);  // ditto!
}; 
```

Q: Can a class-level method call a traditional instance-level method? What about visa-versa? Why?

No, a class method can't call an instance method, because an instance method by definition is associated with an instance, but a class method is not. So when the class method runs, it has no idea what object it's associated with, so it can't call an intance method - which would be associated with a particular object. On the other hand, an instance method can call a class method just fine.

### Classify That Language: Class Functions

Which, if any of the methods in this class are class methods (as opposed to instance methods)?

```rust
struct Nerd {
  name: String,  
  iq: i32
}
 
impl Nerd {
  // constructor
  pub fn new(name: String) -> Nerd {
    return Nerd { name: name, iq: 100 }
  }
    
  pub fn study(&mut self, hrs: i32) {
    self.iq += hrs;
    println!("{} studied {} hours.", self.name, hrs);
    println!("My incredible IQ is now {}.", self.iq)
  }
}
 
fn main () {
  let mut n = Nerd::new("Carey".to_string());
  n.study(3);
}

```

Notice how the study() method has a self parameter (like we see in python, or "this" in C++).  That identifies study() as an instance method. But notice that the new() method - a constructor in this language - does not have a self parameter. That is an indication it's a class method. It has no way of identifying a particular instance/object without a self field. So constructors in this langauge are class-level methods, and they must construct and then return a new object.  This language is Rust!

### This and Self

When a method is called, it must be told what object it is to operate on (so it can find the object's member fields). In most languages, this is done transparently when you call a method on an object p, e.g., p.printMyAddress().  The language passes a reference to p as a hidden extra argument, and it may be referenced in the method as self or this.  Self/this is an object reference or pointer in most languages.

Here's an illustration of how *this* is implemented in c++:

```cpp
// The code you write:
class Nerd {
 private:
   string name;
   int IQ;

 public:
   Nerd(const string& name) {
     this->name = name;
     IQ = 100; // this->IQ is optional
   }

   string talk() {
     return this->name + " likes PI."; 
   }
};

int main() {
 Nerd n("Carey");
 cout << n.talk();
}
```

```cpp
// What's actually happening for the code above:
struct Nerd {
  string name;
  int IQ;
};

void init(Nerd *this, const string& name) {
  this->name = name;
  this->IQ = 100;  
}

string talk(Nerd *this) {
  return this->name + " likes PI.";
}

int main() {
 Nerd n;
 init(&n, "Carey");
 cout << talk(&n);
}

```

And here's an example in Python that uses self:

```python
# Python Nerd class
class Nerd:
 def __init__(self, name):
   self.name = name
   self.IQ = 100

 def talk(self):
   return self.name + " likes closures."
```

In python, using the self. prefix is mandatory, unlike in many other languages where self/this is usually optional (unless we need to bypass shadowing of a local variable).

Here's an example in go:

```golang
// Golang Nerd class
type Nerd struct {
  name string
  IQ   int
}

func New(name string) *Nerd {
 ...
}

func (self *Nerd) Talk() string {
  return self.name + " likes closures."
}

func (self *Nerd) Study(hrs int) {
  self.IQ += hrs
}

...

n := New("Carey")
fmt.Println(n.Talk())
```

It's interesting to note that in Go, the self parameter is explicit and it's placed *before* the function name, all by itself. Then the usual parameters are placed after the function name. 

### This and Self Challenges

Q: Would a class method (as opposed to an instance method) also have a this/self parameter? Why or why not?
A: Class-level methods operate on the overall class and don't even know what instance they're operating on (if any), so no this/self pointer or object reference is passed to them. 


Q: In Python, could you make the self. prefix optional?  If not, why not?
A: In Python as it currently stands the self. prefix is required. While a reference to read a variable could figure out if a variable is a local or a member variable, assigning a variable (without self.) would be problematic. Would a = 5 create a new member variable (self.a) or would it create a new local variable?  Without explicit member variable declarations, which Python doesn't have, assignment without the self prefix would be ambiguous.

### Classify That Language: This and Self

```perl
package Employee;   # Equivalent to a class def.

sub new_employee {  # constructor function
  # Parameters held in $_[0], $_[1], ... $_[n-1]
  # employee name in $_[0], and income in $_[1]
  my $obj = {};   
  $obj->{"name"} = $_[0];   # param 0 is name
  $obj->{"income"} = $_[1]; # param 1 is income
  bless $obj, "Employee";
  
  return $obj;  # return the object
} 

sub compute_ytd_income { # func. to compute income
  my $emp = $_[0];  # 1st param is employee obj
  my $months_worked = $_[1]; 
  return $emp->{'income'} * $months_worked/12;
} 

...

# Code to create/use an employee
use Employee;

$e = new_employee("Ed", 100000);
print "My name: ", $e->{"name"};
print "My income thru Nov is: ",
      $e->compute_ytd_income(11);
```

Q: Does this language have a notion of this/self for objects? Explain!
A: Answer: Yes! When we call a method, e.g., $e-\>compute\_ytd\_income(), this passes the object reference $e as the first argument to the method (as $\_[0]). In this language, function parameters are placed in array called $\_ and you can index them. This is Perl.

### Access Modifiers

As we learned, a key goal of encapsulation is to hide the data/implementation details from users of a class. Languages provide "access modifier" syntax to enable a class to designate what parts of a class are publicly visible and to hide the class's data/implementation.

There are generally three different access modifiers:

- *public*: A public method or data member in class C may be accessed by any part of your program.
- *protected*: A protected method or data member in class C may be accessed by C or any subclass derived from C.
- *private*: A private method or data member in class C may only be accessed by methods in class C.

Public, protected and private generally have the same semantics across languages, though there are exceptions. For instance, Java's protected keyword not only lets subclasses access the member/method, but also lets any other class defined in the same source file.

If you omit an explicit access modifier, different languages have different defaults – some default fields/methods to private, some default to public, etc. Python defaults to public, for example, while C++ defaults to private. 

Here's an example from Swift:

```swift
// Swift access modifiers
class Person {
  private var name: String

  public init(name: String) {
    self.name = name
  }
  public func talk() {
   print("Hi, my name is "+self.name)
  }
  private func poop() {
    print("Grunt... plop!")
  }
}

class Student: Person {
  ... 
  public func dostuff() {
     self.talk()     // Works – talk is public
     self.poop()     // Error – poop private
  }
}

var p = Person(name:"Irna")
p.talk()     // Works – talk is public
p.poop()     // Error – poop private

```

Note: Swift doesn't have a protected keyword! It does have something called *internal* which is similar but slightly different, however.

Here's how we do public/protected/private in Python. It uses underscores to indicate protected/private methods:

```python
# Python access modifiers
class Person:
 def __init__(self, name):
   self.__name = name

 def talk(self):         # Public method
   print("Hi, my name is "+ self.__name)

 def _daydream(self):    # Protected method
   print("Rainbow narwhals")
  
 def __poop(self):       # Private method
   print("Grunt... plop!")


# Derived class
class Student(Person):
 ...
 def do_stuff(self):
   self.talk()           # Works fine - public
   self._daydream()      # Works fine - protected
   self.__poop()      

a = Student("Cindi")
a.talk()          # Works fine - public
a._daydream()     # This works!! - Python doesn't enforce protected methods
a.__poop()        # Generates error
```

#### Encapsulation Best Practices

Here are some things to think about when using encapsulation.

- Design your classes such that they hide all implementation details from other classes.
- Make all member fields, constants, and helper methods private. 
- Avoid providing getters/setters for fields that are specific to your current implementation, to reduce coupling with other classes.
- Make sure your constructors completely initialize objects, so users don't have to call other methods to create a fully-valid object.

#### Classify That Language: Access Modifiers

Our Comedian class has both public and private methods... but no explicit public or private keywords!! Assuming comedians are only serious in private, how does this language hide private members?

```golang
package comedian

type Comedian struct {
  name string
  joke string
}



func (c *Comedian) TellJoke(times int) {
  for i := 1; i < times; i++ {
    fmt.Println(c.joke)
  }
}

func (c *Comedian) GetName() string {
  return c.name
}

func (c *Comedian) beSerious() {
  fmt.Println(c.name + " saves for retirement!\n")
}

func main() {
  c1 := Comedian{"Carey", "Knock, knock..."}
  c1.TellJoke(5)
}
```

Answer: In this language, methods that begin with a capital letter are public, and those that begin with a lower-case letter are private.  This is GoLang!

## Properties, Accessors and Mutators

While our goal in OOP is encapsulation, sometimes we want to expose a field (aka property) of an object for external use. For example, in a Person object we might want to expose a person's name externally.

- A property is some attribute of an object, e.g., a person's age or name.
- An accessor is a method that gets the value of such a property.
- A mutator is a method that changes the value of a property.

Below is how we'd create accessors/mutators in C++ - you have to roll your own.  But many programming languages have syntax to define accessors and mutators more easily.

```cpp
class Person {
public:
  string getName() const;       // accessor
  void setName(string name);    // mutator
};
```

Why use accessors? Accessors and mutators for a property enable us to hide a field's implementation and more easily refactor. 



We have had an introduction to memory safety in [Lecture 8]({{site.baseurl}}/lectures/08). As a recap, memory safe languages prevent any memory operations that could lead to undefined behaviour, while memory unsafe languages allow such operations. To see how memory safety (or lack thereof) can cause problems:
```cpp
class Authenticator {
public:
  bool valid_login(string& user_name, string& pw) {
    string valid_user = "kippy", valid_pw = "woot!";
    lowercase(user_name, lower_name_);
    if (lower_name_ == valid_user && pw == valid_pw)
      let_user_in_ = true;

    return let_user_in_;
  }

 char lower_name_[8];
 bool let_user_in_ = false;
};

int main() {
  string user_name, pw;
  cin >> user_name >> pw;

  Authenticator auth;
  if (auth.valid_login(user_name, pw))
    cout << "Access granted, " << username << endl;
  else
    cout << "Access denied!\n";
}
```
If `user_name` is larger than 8, then the value of `let_user_in_` is overriden and since C++ interprets any non-zero values as `true`, we find that any input of size larger than 8 can cause unintended access.

Do memory leaks lead to undefined behaviour? No! Since memory leaks only lead to unused memory not being freed, they don't lead to undefined behaviour. Even if the system runs out of memory due to the memory leak, the program is *predictably* terminated. Therefore, we see no undefined behaviour. 

## Garbage collection
Garbage collection is the automatic reclamation of memory which was allocated by a program, but is no longer referenced in code. In languages with garbage collection (like Python), the programmer *does not* need to explicitly control object destruction - the languages automatically handles that for the programmer. When a value or an object on the heap is no longer referrenced, the program (eventually) detects this at run time and frees the memory associated with it. 

Garbage collection has multiple advantages:
- It eliminates memory leaks. This ensures memory allocated for objects is freed once it's no longer needed
- It eliminates dangling pointers and the use of dead objects. This prevents access to objects after they have been de-allocated
- It eliminates double-free bugs. This eliminates inadvertent attempts to free memory more than once
- It eliminates manual memory management. This simplifies code by eliminating manual deletion of memory

{: .note }
Garbage collection was pioneered in LISP in the early 1960s. 

### How should objects be garbage collected?
A good rule of thumb is that we should only garbage collect an object when there are no longer any references to that object. For example, if an object goes out of scope, it should be destroyed.
```java
public void do_some_work() {
    Nerd nerd = new Nerd("Jen");
    ...
} // nerd goes out of scope
```
Another example, if an object reference (pointer) is overriden, then the old value should be deleted (as long as it's not being used anywhere else).
```java
public void do_some_work() {
    Nerd nerd = new Nerd("Jen");
    ...
    // we overwrite an obj ref
    nerd = new Nerd("Rick");
    // or 
    nerd = null; 
}
```

### Approaches for garbage collection
Broadly speaking, there are three major approaches for garbage collection. They are
- Mark and Sweep
- Mark and Compact
- Reference counting

In approaches 1 and 2, bulk garbage collection is done when the program runs low on memory (note that the program is temporarily frozen while this happens). In approach 3, the individual objects are garbage collected when their reference count equals zero.

### Mark and Sweep
Mark and Sweep runs in two phases: a **mark** phase and a **sweep** phase. In the mark phase, the program identifies all objects that are still referred to and thus considered to be in-use. In the sweep phase, the algorithm scans all heap memory from start to finish, and frees all blocks not marked as being 'in-use.'

{: .note }
Mark and Sweep was invented by John McCarthy (the inventor of LISP) in 1960!

#### Mark
During the mark phase, our goal is to discover all active objects that are still being used. We consider an object in-use (and its memory not reclaimable) if it meets one of two criteria:
- it is one of a key set of *root* objects. Root objects include global variables, local variables across all stack frames, and parameters on the call stack.
- it is reachable from a root object. If an object can be transitively reached via one or more pointers/references from a root object (e.g.,robot object points to battery).

During the first part of the mark phase, the garbage collector identifies all root objects and adds their object references to a queue for investigation. During the second part, the garbage collector uses the queue to breadth-first search from the root objects and mark all the reachable objects as "in-use". To do this, each object is augmented with a bit (hidden from the programmer usually) which is set by the GC to mark that it is in use. Once all reachable objects have been marked, all unmarked objects can be disposed of.

Here is the pseudocode for the mark algorithm.
```python
# Pseudocode for the Mark algorithm
def mark():
  roots = get_all_root_objs()
  candidates = new Queue()
  for each obj_ref in roots:
    candidates.enqueue(obj_ref) 

  while not candidates.empty():
    c = candidates.dequeue()
    for r in get_obj_refs_in_object(c):
      if not is_marked(r):
        mark_as_in_use(r)
        candidates.enqueue(r)
```

How does the GC find unmarked objects? This is done in the sweep phase.

#### Sweep
In the sweep phase, we traverse all memory blocks in the heap (each block holds a single object/value/array) and examine each object's "in-use" flag. 

{: .note }
Rather than use a queue, the mark and sweep algorithm can use a clever pointer manipulation trick instead. You can think of this as a breadth-first or depth-first traversal. Since all blocks in the heap are linked together top-to-bottom in a linked list, we only need to traverse linked list and remove those objects which are not "in-use".

Here is the pseudocode for the sweep algorithm.
```python
# Pseudocode for the Sweep algorithm
def sweep():
    p = pointer_to_first_block_in_heap()
    end = end_of_heap()
    while p < end:
        if is_object_in_block_in_use(p):
            reset_in_use(p)      # remove the mark, object lives
        else:
            free(p)                        # free this block/object
        p = p.next
```

Here are some pros/cons of Mark and Sweep

Pros:
- It's relatively simple
- It has no trouble with cyclic references

Cons:
- Program must be paused during GC, causing "freezes"
- Not great for real-time apps because of freezes
- Dealing with large amounts of data can lead to thrashing pages
- Classic mark and sweep can cause memory fragmentation

### Mark and Compact
Mark and compact is a twist on mark and sweep designed to address the issue of memory fragmentation. In Mark and Compact, the mark phase proceeds exactly the same as in mark and sweep. However, once we are done marking, we don't sweep away unmarked objects! Instead, we compact all marked/in-use objects to a new contiguous memory block. Then we can adjust the pointers to the proper relocated addresses. Our original block of memory can be treated as if it's empty and can be reused without dealing with any sweeping. 

Here are some pros/cons of Mark and compact.

Pros:
- It eliminates memory fragmentation
- It has no trouble with cyclic references

Cons:
- Much more complex to implement
- Not great for real-time apps because of freezes
- Requires more RAM to deal wih compaction
- The algorithm is even slower than mark and sweep!

### Reference counting
In reference counting GC, every object has a (hidden) reference counter attached to it that tracks how many references there are to it. Every time a new reference is created to an object, the languages secretly increments the counter, and vice versa. When the reference count of an object reacher zero, then it can be destroyed. When an object is destroyed, all objects transitively referenced by that object must also have their reference counts decremented. This can cause a cascading deletion of objects, all being freed at once (which is slow).

To mitigate this, instead of destroying an object as soon as its counter becomes zero, we can add it to a list of pending objects, and then reclaim memory regularly over time.

Here are some pros/cons of reference counting GC.

Pros:
- It is simple
- Memory reclamation doesn't cause hangs, and is (usually) real-time
- Efficient memory usage since blocks are freed immediately.

Cons:
- Updating reference counts must be done in a thread-safe way
- Need to update reference counts on each pointer operation
- Cascading deletions can lead to uneven memory usage patterns at run time
- References take up alot of extra space
- Requires explicit handling of cyclic references

## Destructors, Finalizers and Disposers
Many objects hold resources (e.g.: dynamic objects, temp files) which need to be released when their lifetime ends. There are three ways this is handled in modern languages, namely destructors, finalizers, and disposers.

### Destructors
Destructors are only used in languages with manual memory management, like C++. There are deterministic rules that govern when destructors are run, so the programmer can ensure *all* of them will run, and control *when* they run. Since the programmer can control when they run, you can use destructors to release critical resources at the right times: e.g., freeing other objects, closing network connections, deleting files, etc. 

Here is an example of destructors in action in C++.
```cpp
void doSomeProcessing() {
   TempFile *t = new TempFile();
  
   ...
 
   if (dont_need_temp_file_anymore()) 
     delete t; // explicit call to a destructor
  
   ...
}

void otherFunc() {
  NetworkConnection n("www.ucla.edu");

  ...
} // destructor for n called when it goes out of scope
```

### Finalizers
In GC languages, memory is reclaimed automatically by the garbage collector. So finalizers are used to release unmanaged resources like file handles or network connections, which aren't garbage collected. Unlike a destructor, a finalizer may not run at a predictable time or at all, since objects can be garbage collected at any time (or not at all)! Since they can't be counted on to run, they're considered a last-line of defense for freeing resources, and often not used at all! We'll learn more about finalizers when we cover Object Oriented Programming.

Here are some examples of finalizers in Java and Python.
```java
// Java finalization example
public class SomeClass {
 
  // called by the garbage collector
  protected void finalize() throws Throwable
  {
    // Free unmanaged resources held by SomeObj 
    ...
  }
}
```
```python
# Python finalizer method
class SomeClass :
  ...

  # called by the garbage collector
  def __del__(self):
     # Finalization code goes here
     ...
```

### Disposers
A disposal method is a function that the programmer must manually call to free non-memory resources (e.g., network connections). You use disposal methods in GC languages because you can't count on a finalizer to run!. Disposal provides a guaranteed way to release unmanaged resources when needed. However, we run the risk of forgetting to call the disposer.

Here is an example of a disposer in C#.
```cs
// C# dispose example
public class FontLoader : IDisposable
{
  ...
    
  public void Dispose()
  {
     // do manual disposal here, e.g., free
     // temp files, close network sockets, etc.
  }
}

...

var f = new FontLoader(...);
... // use f to draw fonts
f.Dispose();
```

## Function Palooza
In Function Palooza, we will be doing a deep dive into functions. We'll understand how functions pass arguments and receive parameters,  how languages return value(s) from functions, how languages communicate errors across functions, how functions can be passed as arguments, returned and stored in variables, and how to design functions to operate on a variety of different types of inputs.

### Definitions
#### Actual and Formal Parameters
The arguments in the definition of a function are called the **formal** parameters of the function. The arguments we pass to a function when we call it are called the **actual** parameters of the function. For example
```cpp
double net_worth(double assets,  // formal parameters
                 double debt) {
  return assets – debt;
}

int main() {
 cout << "Your net worth is: " <<
   net_worth(10000, 3500); // actual parameters
}
```

#### Positional and Named Parameters
In languages that support **positional** parameters, the order of the arguments must match the order of the formal parameters. For example,
```cpp
bool sum(float arr[], int n) {
  float sum = 0;
  for (int i=0; i < n; ++i) {
    sum += arr[i];
  }
  return sum;
}

int main() {
 float arr[3] = {78,99,65};

 cout << "The sum is: " <<
   sum(arr, 3);
}
```

In languages that support **named** parameters, the call can explicitly specify the name of each formal parameter (called an *argument label*) for each argument. For example,
```cpp
def net_worth(assets,debt):
    return assets - debt

print("Your net worth is: ",
      net_worth(assets=10000,
                debt=3500))

print("Their net worth is: ",
      net_worth(debt=45000,
                assets=19000))
```
Many languages (like C++) support a combination of positional and named parameters.
```cpp
print("Your net worth is: ",
      net_worth(10000,
                debt=3500))
```
Positional parameters allow for a less wordy syntax since we don't need to specify an argument label for each argument. The disadvantage is that we *have* to pass the arguments in the same order as the formal parameters, and this can lead to bugs when we pass arguments in an incorrect order. With named parameters, you can add parameters and shift their order around more easily since each parameter is named. A change in order won't cause a bug. It also makes code more readable, if a bit more verbose, since you know what each argument is.

#### Default Parameters
Most languages let you specify default values for specified formal parameters, making these parameters optional in the function call. For example,
```cpp
double net_worth(double assets, 
                 double debt = 0) {
  return assets – debt;
}

int main() {
 cout << "Your net worth is: " <<
   net_worth(10000, 3500);
}
```
One or more formal parameters may have a default value. This makes passing the argument optional. If you decide to omit the associated argument to a formal parameter, the provided default value will be used. In languages (like C++ or Python) which do not have mandatory argument labels, default parameters must all be place at the *end* of the parameter list. This means that a definition like the following would be illegal in a language like Python.
```python
double net_worth(double assets, 
                 double debt = 0,
                 double inheritance = 0) {
  return assets – debt + inheritance;
}
```
However, in languages with mandatory argument labels (like Swift), default values can be used for any parameter.
```swift
// Swift optional parameters
func net_worth(assets: Double, debt: Double=0,
               inheritance: Double) -> Double 
  { return assets-debt+inheritance }

func main() {
 print(net_worth(assets: 10000, inheritance: 500))
}
```

Some languages like Python or FORTRAN allow to have optional parameters without default values! A function can check if a given argument was present when the function was called and act accordingly. Here is an example in Python.
```python
# Python optional parameters
def net_worth(assets, debt,**my_optionals):
    total_worth = assets - debt
    if "inheritance" in my_optionals: // checking if argument exists
        total_worth = total_worth + 
                      my_optionals["inheritance"]
    return total_worth

print("Net-worth: ", net_worth(10000, 2000))
print("Net-worth: ",
      net_worth(10000, 2000, inheritance=50000))
```
Here is another example, now in FORTRAN.
```fortran
! Fortran function with an optional parameter
real function net_worth(assets,debt,inheritance)
    real :: assets
    real :: debt
    real, optional :: inheritance
    
    real :: total_worth

    total_worth = assets - debt
    if (present(inheritance)) THEN
        total_worth = total_worth + inheritance
    end if
    net_worth = total_worth  ! specify return value
end function net_worth
```

{: .note }
Python optionals aren't great because you can't easily look at the function prototype and figure out what options there are!

#### Variadic functions
A variadic function is a complex term that just means you can pass a variable number of arguments to a function. The canonical use case for such a function is printing a bunch of values.
```python
# Python's print function is variadic
# You can pass any # of arguments to it!
print(1)
print(1,"a")
print(1,3.14159,"c",4,"foobar")
```
To implement variadic functions, most languages gather variadic arguments and add them to a container (e.g., to an array, dictionary or tuple) and pass that container to the function for processing.
A notable exception is C++ which requires use of convoluted library functions to access variadic arguments!

Here are some examples of variadic functions in various languages.

**Java**

In Java, you may have zero or more fixed parameters. For the variadic parameters, Java creates an array containing every variadic argument and passes it to the variadic parameter.
```java
// Java variadics use an array-like approach
public class VariadicExample {
 private void f(String regular, int... vparams) {
   System.out.println(regular);
   for (int i = 0; i < vparams.length; i++)
     System.out.println(vparams[i]);
 }

 public void someFunc() {
   f("Four #s",2,4,6,8); 
 }
}
```

{: .note }
In Java, all variadic parameters must have the same type. To deal with variadic parameters of differing types in Java, we can take advantage of the fact that all boxed primitives are derived from the `Object` class. So we could make a variadic of type `Object`, and then use type reflection (`instanceof`) to differentiate between types and specialise behaviour by argument.

**JavaScript**

In JavaScript we don't specify variadic parameters in the function declaration, you just specify fixed parameters. JavaScript provides a builtin `arguments` array which is populated with *all* arguments (fixed and variadic).
```js
// JavaScript variadics

function f(fixed1, fixed2) {
  console.log("Fixed: " + fixed1 + " " + fixed2)
  console.log("Varargs:")
  for (var i=2; i<arguments.length; i++)
    console.log(arguments[i])
}

f(1,"two","three",4.01);  
  // Fixed: 1 two
  // Varargs: three 4.01
```

**Python**

Python created a tuple containing each variadic argument and then passes it to the function. You can then enumerate over the tuple as desired.
```python
# Python variadics
def f(fixed1, *args):
  print("First param: ", fixed1)
  print("Everything after first arg:")
  for arg in args:
    print(arg)

f(1,"two","three",4.0)
```

**C++**

Variadics in C++ are a little more tricky. Variadic arguments are identified by the formal parameter of `...`. C++ doesn't have any way of determining the number of variable arguments, so we have to somehow specify this ourselves (i.e. by passing a fixed parameter with the number of arguments). 
```cpp
// C++ variadics are janky ☺
#include <stdarg.h>
 
void vprint(int count, ...) {
    va_list args;
    va_start(args, count);
    while (count--) {
      cout << va_arg(args, double) << " ";
    }
    va_end(args);
}
 
int main() {
  vprint(3, 3.14159, 2.718, 32.0);
}
```
To start processing variadic arguments, you have to create a `va_list` argument and then you have to call the `va_start` function with the name of the last *fixed* parameter. You can then call the `va_arg` function to get to each argument, and also advance to the next one. You finally call `va_end` to finish processing the variable arguments. You also have to specify the type of each value in C++, it won't know it otherwise (this is because C++ doesn't have type reflection). 
