---
title: Lecture 6 Continued - python-part3
week: 3
lecture_date: 2022-10-12
author: Ashwin Ranade
layout: lecture
parent: Lecture Notes
---
{: .note }
Ashwin here! This continues from [last lecture]({{site.baseurl}}/lectures/06), and covers the slides 42-72 on `python_intro_v1`. These are referencing [this](https://bruinlearn.ucla.edu/courses/140089/files/10874289?module_item_id=5458744) video lecture, meant as a continuation of lecture 6. 

## Table of Contents
{: .no_toc }

{:toc}
- dummy item

## Strings!
- In Python, each string is an object just like our Circle objects!
- Strings are **immutable**, meaning they can't be modified once created.

```
fact1 = 'Del Taco rules! '
fact2 = 'CS131 is lit! '

truth = fact1 + fact2

truth += 'I have spoken.'
```
- The code to the left appears to mutate the string referred to by truth.
- This line looks like it mutates the object referred to by truth - but in reality, it creates a **NEW** string object!
  - Then it changes the object reference to point at the new object!
  - At some later time, our original string is garbage collected!
- Python generates/trashes lots of objects as your code runs – and you don't even know it!

### Substrings
```
# String slicing in Python
truth = 'UCLA students are awesome!'
print(truth[6]) #t
print(truth[1:3]) #CL    
print(truth[:4]) #UCLA 
print(truth[22:]) # some!
print(truth[-4:-1]) # ome
```
- substring of length 1 from `a`: `str[a]`
- substring from indices `[a-b)`, `str[a:b]`
  - when first param is empty, 0 is assumed: `str[:b]` is the same as `str[0:b]`
  - when the second param is empty, End is assumed: `str[a:]` <-> `str[a:End+1]`
- negative indices: represent relative to the end of the string
  - `str[-1]` is the last character in str
  - `str[:-1]` = `str[:len(str)-1]`

### Cool String Functions
- `strip(delimiter)` splits a string into an array of strings based on a delimiter (defaults to whitespace)
- `upper(x)` returns x all uppercase

## Lists
- Like strings, lists are objects in Python – and they support the same operations as strings!
- But, **lists are mutable**!

{: .note }
Assignment still creates a whole new object, despite lists being mutable. For example, `stuff = stuff + ['subpar']` is created a new `stuff` list. 

```
stuff = [42, False, 'walnuts']

stuff[2] = 'USC students'
stuff[0:2] = ["It's", 4, 'real']
stuff.append('are')    # or stuff += ['are']

stuff = stuff + ['subpar']
print(stuff[3:])
if 'walnuts' not in stuff:
  for s in stuff:
    print(s)
------------------------------
['USC students', 'are', 'subpar']
It's
4
real
USC students
are
subpar
```

### List Implementation + Complexity
- Accessing the jth element of a list, e.g., x[j] is super fast!
- Lists are implemented with dynamically-allocated arrays of object references.

**big-O**
- `in` and `not in`: `O(n)`
- `list[j]` where j is large: `O(1)`
- appending one list to another: `O(m+n)`

### Lists of Lists
```
x = [1,2]
lol = [[1],x]
x = [2]
print(x)
-------
[[1],[1,2]]
```
In `x = [2]`, we **re-assign** x, and hence it doesn't affect our original list `lol`!

## Tuples
Python tuples are immutable, ordered groups of items, e.g.,  
`([1,2,3],False)`, `(1,True,'foo')`, etc.

## Sets
- sets can only contain unique elements
- operations: `.add`, `.remove`

```
draining = set()

draining.add('studying')
draining.add('CS131')
draining.add('dating')     draining.add('studying')
draining.remove('CS131')
print(draining)

if 'CS131' not in draining:
  print('Studying for CS131 is NOT draining!')

# Let's create a set from a list...
dinner = ['salad','soup','steak','soup','pie']
dinner_set = set(dinner)
print(f'Unique foods: {dinner_set}')
---------------------------------
{'dating', 'studying'}
Studying for CS131 is NOT draining!
Unique foods: {'soup', 'steak', 'pie', 'salad'}
```

Note: Python dictionaries are insertion-ordered as of Python 3.5, but sets are still unordered.































