---
title: Lecture 5
week: 3
lecture_date: 2022-10-10
author: Ashwin Ranade
layout: lecture
parent: Lecture Notes
---

## Table of Contents
{: .no_toc }

{:toc}
- dummy item

Note: In a code block, the characters below `-------------` represents the output of the Python program above the `-------------`. 

For example:
```
<python program>
----
<output of python program>
```
# Intro to Python

## Background

Python uses: 
- quick and dirty scripting
- industrial scripts

Basic Python facts: 
- open source
- no compiler, just interpreters (we will use CPython)
- Avoid Python for: writing efficient programs (since it's interpreted)
  -  note: Python modules can use code from other languages (e.g. C++) for optimization (e.g. PyTorch, TensorFlow, NumPy)

### Python Shell

Python Shell can be used: 
- interactively
- to run programs saved in `.py` files
```
climberkip$ python3
Python 3.9.6
<a bunch more boilerplate removed for clarity>
>>> def f(x,y):
...  print(f'{x} + {y} is {x+y}')
... 
>>> f(10,20)
10 + 20 is 30
>>> bar = 10
>>> bar/3 + 5
8.3333333333333334
>>> ^D
```
 - `...` indicates multi-line function
- exit shell with Ctrl-D or `quit()`

## Basic Intro, through Challenges

`import this` => Python Design Principles [link](https://peps.python.org/pep-0020/)

- **Formatting**: blocks defined by colon + indentation; no block delimiter `{` or statement delimiter `;`
- **Program Execution**: Interpreter runs file from top-to-bottom; no default main() function

Pythonic main function: 
```
if __name__ == "__main__":
  main()
```
- Python sets `__name__` to `__main__`, telling us to run main function

- **Functions**: 
  - no parameter type annotation or return types
  - default params allowed; we can explicitly specify param names when calling functions

ex: 
```
def smoosh(x,y): 
  return x + y 

print(smoosh(y=10,x=20))
```
This returns `30`

### Variables and Types
- definition not required; type not required; variables can be assigned to different types over time
  - same function can be applied to different types

ex: overloaded `+` operator for strings and ints 
```
def add_n_print(x,y): 
  print(x+y)
  
 add_n_print(10,20)
 add_n_print("I <3 ", " coding")
```

**Type Errors + Dynamic Type Checking**
```
def add_n_print(x, y):
 print(x + y)              # Line 1

def main():
 add_n_print('foo', 5)     # Line 2
```
Error:
```
TypeError: can only concatenate str (not "int") to str
```
Error is generated when the code reaches line #1 at runtime, after `add_n_print` is called from the main function.

{: .note }
Python uses dynamic checking, versus statically typed languages like C++. Dynamic checking means we only check the operand types the moment the operation occurs.

Python type hints are **NEVER** enforced by Python interpreter, although they are used by 3rd party tools and are considered good practice.

The following code runs fine: 
```
def make_bday_msg(name: str, age: int) -> str:
  msg: str = f'Happy {age}th birthday, {name}!'
  return msg

say_this: str = make_bday_msg(3.14159, 'hamsters')
print(say_this)
```

And prints: 
```
Happy hamstersth birthday, 3.14159!
```

**More Python Syntax**

Python has big ints that can hold any size integer; the array representing the integer can dynamically grow to any size.  
```
THRESHOLD = 1000000000
big = 2**200   # exponentiation
if big > THRESHOLD:
  print(f'{big} is really big!')
---
1606938044258990275541962092341162602522202993782792835301376 is really big!
```
- all caps variables can be considered constants, although they can be reassigned, so technically not constants

- `/` operator always produces a double result: `//` always produces an integer result (integer division)
```
kittens = 5 / 2 #2.5
puppies = 5 // 2 #2
```

- Python's `input()` function always returns a string
  - we can convert to different types with `float()` or `int()`
```
#assume input is Binh 3.62 18 [each on a different line]
nm = input('Your name: ')
print(f'{nm} is {type(nm)}')
gpa = float(input('Your GPA: '))
print(f'{gpa} is {type(gpa)}')
age = int(input('Your age: '))
print(f'{age} is {type(age)}')
---
Your name: Binh
Binh is <class 'str'>
Your GPA: 3.62
3.62 is <class 'float'>
Your age: 18
10 is <class 'int'>
```
**Variables and Scope**
- in Python, once you define a variable, it stays in scope until function ends (unlike C++)

```
def foo(): 
  if True: 
    x = 10
  print(x)
foo()
----------------
10
```
**Loops**

- `range(x,y,z)` returns a sequence of integers between `[x,y)`, advacing by `z` each iteration (`z` is default 1).
  - `range(5,9,2)` => `[5,7]`
- `break` terminates a loop

## Classes and Objects
### Classes
Instantiating a class `Car` and using an object of the `Car` class:
```
c1 = Car(16) #instantiation
c1.drive(10) #calling a method of the Car class
```

Class definition:
```
class Car:
  MILES_PER_GAL = 30
  def __init__(self, gallons):
    self.gas_gallons = gallons
    self.odometer = 0

  def drive(self, miles):
    gals_needed = miles / Car.MILES_PER_GAL
    if self.gas_gallons > gals_needed:
      self.gas_gallons -= gals_needed
      self.__update_odometer(miles)

  def __update_odometer(self, miles):
    self.odometer += miles

  def get_odometer(self):
    return self.odometer
```
- first param of each method must be `self` (`this` in C++)
  -  normal functions have no `self` param
-  constructor: `__init__`
-  we can't declare a class's member variables without assigning them (unlike C++)

_question:_ Why does changing `get_odemeter()` to: 
```
def get_odometer(self): 
  return odemeter
```
result in an error? 

_answer:_ We refer to class variables through `self.odometer` inside Python classes. `odemeter` now refers to a (non-existent) local variable!

_more classes_
- calling a method from another method: same as class variables, use the `self.` prefix
- private method: prefix with 2 underscores (`__update_odometer`); all other methods are public by default

{: .note }
Definition of a Python class is a sequence of statements, just like a regular Python program!
For example, this code is legal: 
```
  print('I like traffic lights')
  def drive(self,miles):
    print(f'I drove {miles} miles!')
  print ("As long as they're green")
```

### Objects
Python allocates objects using **object references**. 

Syntax: use the `.` dot operator to call methods through object references
```
c = Circle(10)
print(c.area())
```

- Every Python object is allocated on the heap (unlike C++, where we can choose between stack and heap)
- ALL variables are object references!
- even integer variables created through things like `i = 42` are object references that point to an integer value sitting in heap memory
  - in practice, you can view things like `i = 42 \n i = 10` as reassigning i's value when `i` is a primitive
  - under the hood, `i` first points to 42; then, a new object `10` is allocated on the head, and `i` changes its pointer to the new object

{: .note }
Every Python object is allocated on the heap, and then pointed to be an object reference. 

![image](https://user-images.githubusercontent.com/6395723/196106783-00b7ea78-28d7-4dcc-ba87-9fa32dd4ac1d.png)

**Construction Object**

`c = Circle(10)`
- Before our constructor runs, Python allocates RAM for a new Circle object
  - `self` param of the object points at the newly reserved block of RAM
  - member variables are dynamically created and then assigned inside the block of RAM
- finally, the variable (object reference, in this case `c`) is assigned so that it points to the `Circle` object

_Question:_ Is every Python object of a given class guaranteed to have the same set of member variables? 
_Answer:_ No. Example:
```
def __init__(self, rad):
    self.rad = rad
    if rad > 100:
      self.really_big_circle = True
```

**Method Calling**
`print(c.area())`
- when we call a method, Python passes the object reference to the `self` param

**Copying of Objects:** Assignment of object references means both object references will point to the same object! Hence, a change in one object, will affect both!

```
c = Circle(1)
c2 = c
c.set_radius(10) #c and c2 radius is BOTH changed to 10
```

Making a copy: 
```
import copy
c = Circle(1)
c2 = copy.deepcopy(c)
```

**Garbage Collection + Destructors:**
- Python has automatic GC
- as long as some variables refer to an object, the object is kept around

Destructors: rarely used; if an object is garbage collected (not guaranteed), the destructor will automatically be called
- Python **automatically** frees allocated objects in C++, so we don't have to do that in Python destructors!

Destructor example
```
 def __del__(self):
    if self.book.finished_reading():
      print("You graduated!")
```

Destructors could be used to free a system resource that's not managed by GC. However, since we have no guarantee that the destructor will ever run, we should define our own _tear-down method_ and explicitly call it!

Example of an explicit tear-down method: 
```
  def delete_temp_file(self):
    self.tmpfile.close()         # closes file
    os.remove(self.tmpfile.name) # deletes file
```

### Inheritance
`class Student(Person)` -> derived class `Student` is inherited from base class `Person`

- you may re-define any method in derived class (methods are virtual by default)
- derived class can call any base class method with `super()` prefix
- make sure the derived constructor calls the base class constructor! `super().__init__(name)`

Example:
```
class Person:
  def __init__(self, name):
    self.name = name

  def talk(self):
    print('Hi!\n')

  def get_name(self):
    return self.name

class Student(Person):
  def __init__(self, name):
    super().__init__(name)
    self.units = 0

  def talk(self):
    print(f"Heya, I'm {super().get_name()}.")
    print("Let's party! Oh... and ")
    super().talk();
```

### Duck Typing

